C51 COMPILER V9.60.0.0   NUMSHOW                                                           06/25/2021 02:42:34 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE NUMSHOW
OBJECT MODULE PLACED IN .\Objects\NumShow.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE NumShow.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\N
                    -umShow.lst) TABS(2) OBJECT(.\Objects\NumShow.obj)

line level    source

   1          /** RS485.c */
   2          #include <intrins.h>
   3          #include <reg52.h>
   4          
   5          sbit RS485_DIR = P1 ^ 7;        // RS485方向选择引脚
   6          
   7          bit flagFrame = 0;              // 数据帧接收完成标志位，表示接收到了一帧新数据
   8          bit flagTxd = 0;                // 单字节发送完成标志位，用来替代 TXD 中断标志位
   9          
  10          unsigned char cntRxd = 0;       // 接收字节计数器
  11          unsigned char pdata bufRxd[64]; // 接收字节缓冲区
  12          
  13          extern void UartAction(unsigned char *buf, unsigned char len);
  14          
  15          /* 串口配置函数，baud-通信波特率 */
  16          void ConfigUART(unsigned int baud) {
  17   1        RS485_DIR = 0;                           // 将 RS485 设置为接收
  18   1      
  19   1        SCON = 0x50;                             // 配置串口为工作方式 1
  20   1        TMOD &= 0x0F;                            // 清零定时器 T1 控制位
  21   1        TMOD |= 0x20;                            // 配置定时器 T1 为工作模式 2
  22   1        TH1 = 256 - (11059200 / 12 / 32) / baud; // 计算定时器 T1 初始值
  23   1        TL1 = TH1;                               // 将高位定时值作为低位的初值
  24   1        ET1 = 0;                                 // 禁用定时器 T1 中断
  25   1        ES = 1;                                  // 串口中断使能
  26   1        TR1 = 1;                                 // 启动定时器 T1
  27   1      }
  28          
  29          /* 软件延时函数，延时 t * 10 微秒的时间 */
  30          void DelayX10us(unsigned char t) {
  31   1        do {
  32   2          _nop_();
  33   2          _nop_();
  34   2          _nop_();
  35   2          _nop_();
  36   2          _nop_();
  37   2          _nop_();
  38   2          _nop_();
  39   2          _nop_();
  40   2        } while (--t);
  41   1      }
  42          
  43          /* 串口数据写入函数，参数 buf 是等待发送数据的指针，参数 len 是发送的长度 */
  44          void UartWrite(unsigned char *buf, unsigned char len) {
  45   1        RS485_DIR = 1;       // 将 RS485 设置为发送
  46   1      
  47   1        /* 循环发送所有的字节 */
  48   1        while (len--) {
  49   2          flagTxd = 0;       // 发送完成标志位清零
  50   2          SBUF = *buf++;     // 发送 1 个字节的数据
  51   2          while (!flagTxd) ; // 等待该字节发送完成
  52   2        }
  53   1      
  54   1        DelayX10us(5);       // 等待最后的停止位完成，延时时间由波特率决定
C51 COMPILER V9.60.0.0   NUMSHOW                                                           06/25/2021 02:42:34 PAGE 2   

  55   1        RS485_DIR = 0;       // 将 RS485 设置为接收
  56   1      }
  57          
  58          /* 串口数据读取函数，参数 buf 表示接收指针的指针，参数 len 表示读取的长度，返回值是实际读取到的长度 */
  59          unsigned char UartRead(unsigned char *buf, unsigned char len) {
  60   1        unsigned char i;
  61   1        /* 当指定的读取长度大于实际接收到的数据长度时，将读取长度设置为实际接收到的数据长度 */
  62   1        if (len > cntRxd) {
  63   2          len = cntRxd;
  64   2        }
  65   1      
  66   1        /* 将接收到的数据拷贝至接收指针 */
  67   1        for (i = 0; i < len; i++) {
  68   2          *buf++ = bufRxd[i];
  69   2        }
  70   1      
  71   1        cntRxd = 0; // 接收计数器清零
  72   1        return len; // 返回实际读取的长度
  73   1      }
  74          
  75          /* 串口接收监控函数，基于空闲时间来判定帧结束，在定时中断中调用，参数 ms 表示定时间隔 */
  76          void UartRxMonitor(unsigned char ms) {
  77   1        static unsigned char cntbkp = 0;  // 接收计数变量
  78   1        static unsigned char idletmr = 0; // 总线空闲计时变量
  79   1      
  80   1        /* 当接收计数变量大于零时，监听总线的空闲时间 */
  81   1        if (cntRxd > 0) {
  82   2          /* 如果接收计数变量发生改变（即刚接收到数据时），空闲计时变量清零 */
  83   2          if (cntbkp != cntRxd) {
  84   3            cntbkp = cntRxd;
  85   3            idletmr = 0;
  86   3          }
  87   2          /* 如果接收计数变量没有改变（即总线保持空闲时），将空闲时间进行累加 */
  88   2          else {
  89   3            /* 总线空闲计时小于 30ms 持续累加 */
  90   3            if (idletmr < 30) {
  91   4              idletmr += ms;
  92   4              /* 总线空闲计时达到 30ms，就认为一帧数据接收完毕 */
  93   4              if (idletmr >= 30) {
  94   5                flagFrame = 1;            // 设置数据帧接收完成标志位
  95   5              }
  96   4            }
  97   3          }
  98   2        } else {
  99   2          cntbkp = 0;
 100   2        }
 101   1      }
 102          
 103          /* 串口驱动函数，用于监听数据帧的接收并调用相应功能，主函数循环中进行调用 */
 104          void UartDriver() {
 105   1        unsigned char len;
 106   1        unsigned char pdata buf[40];
 107   1        /* 当数据帧到达时，读取并处理该命令 */
 108   1        if (flagFrame) {
 109   2          flagFrame = 0;
 110   2      
 111   2          len = UartRead(buf, sizeof(buf) - 2); // 将接收到的命令读取至缓冲区
 112   2          UartAction(buf, len);                 // 传递数据帧，调用动作执行函数
 113   2        }
 114   1      }
 115          
 116          /* 串口中断服务函数 */
C51 COMPILER V9.60.0.0   NUMSHOW                                                           06/25/2021 02:42:34 PAGE 3   

 117          void InterruptUART() interrupt 4 {
 118   1        /* 接收到新的字节数据 */
 119   1        if (RI) {
 120   2          RI = 0;      // 接收中断标志位清零
 121   2      
 122   2          /* 接收缓冲区尚未用完时，保存接收字节，并递增计数器 */
 123   2          if (cntRxd < sizeof(bufRxd)) {
 124   3            bufRxd[cntRxd++] = SBUF;
 125   3          }
 126   2        }
 127   1        /* 字节发送完毕 */
 128   1        if (TI) {
 129   2          TI = 0;      // 发送中断标志位清零
 130   2          flagTxd = 1; // 发送完成标志位置 1
 131   2        }
 132   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    293    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     64      40
   DATA SIZE        =      3       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
