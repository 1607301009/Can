C51 COMPILER V9.60.0.0   MAIN                                                              06/27/2021 01:42:17 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          
   3          sbit dula = P2 ^6;        //段选信号的锁存器控制
   4          sbit wela = P2 ^7;        //位选信号的锁存器控制
   5          
   6          /* 数码管编码表 */
   7          unsigned char code
   8          LedChar[] = {
   9          0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71, 0x00};
  10          
  11          /* 动态数码管显示缓冲区*/
  12          unsigned char LedBuff[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  13          
  14          unsigned char code
  15          table[]={
  16          0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0xfe};  //数码管各位的码表
  17          
  18          unsigned char i = 0;    // 动态扫描索引
  19          unsigned int cnt = 0;   // 定时器 T0 中断次数
  20          unsigned char flag = 0; // 定时 1 秒标志
  21          
  22          
  23          void setDisplayNum(unsigned long Num, unsigned long base) //显示程序
  24          {
  25   1          /* 将 Num 按照base进制由低至高，提取为数码管将要显示字符的编码 */
  26   1          unsigned long pow2 = base * base;
  27   1          unsigned long pow3 = base * base * base;
  28   1          unsigned long pow4 = base * base * base * base;
  29   1          unsigned long pow5 = base * base * base * base * base;
  30   1      
  31   1          LedBuff[0] = LedChar[Num % base];
  32   1          if (Num >= base) { LedBuff[1] = LedChar[Num / base % base]; } else { LedBuff[1] = 0x00; }
  33   1          if (Num >= pow2) { LedBuff[2] = LedChar[Num / pow2 % base]; } else { LedBuff[2] = 0x00; }
  34   1          if (Num >= pow3) { LedBuff[3] = LedChar[Num / pow3 % base]; } else { LedBuff[3] = 0x00; }
  35   1          if (Num >= pow4) { LedBuff[4] = LedChar[Num / pow4 % base]; } else { LedBuff[4] = 0x00; }
  36   1          if (Num >= pow5) { LedBuff[5] = LedChar[Num / pow5 % base]; } else { LedBuff[5] = 0x00; }
  37   1      }
  38          
  39          void scanDisplayNum() //显示程序
  40          {
  41   1          P0 = 0x00;  // 消除残影
  42   1      
  43   1          /* 数码管动态扫描刷新 */
  44   1          P0 = table[i];
  45   1          wela = 0;
  46   1          wela = 1;
  47   1      
  48   1          P0 = 0x00;  // 消除残影
  49   1          P0 = LedBuff[i];
  50   1          dula = 0;
  51   1          dula = 1;
  52   1      
  53   1          switch (i) {
  54   2              case 5:
C51 COMPILER V9.60.0.0   MAIN                                                              06/27/2021 01:42:17 PAGE 2   

  55   2                  P0 = 0x00;  // 消除残影
  56   2                  P0 = table[i];
  57   2                  wela = 0;
  58   2                  wela = 1;
  59   2                  P0 = 0x00;  // 消除残影
  60   2                  P0 = LedBuff[i];
  61   2                  dula = 0;
  62   2                  dula = 1;
  63   2                  i = 0;
  64   2                  break;
  65   2              default:
  66   2                  P0 = 0x00;  // 消除残影
  67   2                  P0 = table[i];
  68   2                  wela = 0;
  69   2                  wela = 1;
  70   2                  P0 = 0x00;  // 消除残影
  71   2                  P0 = LedBuff[i];
  72   2                  dula = 0;
  73   2                  dula = 1;
  74   2      
  75   2                  i++; break;;
  76   2          }
  77   1      }
  78          
  79          void main() {
  80   1          unsigned long sec = 16; // 消耗的秒数
  81   1      
  82   1          TMOD = 0x01;            // 设置 T0 为模式 1
  83   1          TH0 = 0xFC;
  84   1          TL0 = 0x67; // 设置定时值存储寄存器，定时 1ms
  85   1      
  86   1          EA = 1;  // 使能总中断
  87   1          ET0 = 1; // 使能 T0 中断
  88   1          TR0 = 1; // 启动 T0
  89   1      
  90   1          while (1) {
  91   2              /* 判断 1 秒定时标志 */
  92   2              if (flag == 1) {
  93   3                  flag = 0; // 定时 1 秒标志清零
  94   3                  sec++;    // 秒计数自增 1
  95   3      
  96   3                  setDisplayNum(sec, 16);
  97   3              }
  98   2          }
  99   1      }
 100          
 101          /* 定时器 T0 中断服务函数 */
 102          void InterruptTimer0()
 103          
 104          interrupt 1 {
 105   1      TH0 = 0xFC;
 106   1      TL0 = 0x67; // 定时值存储寄存器重新赋初值
 107   1      cnt++;                  // 中断次数计数值自增 1
 108   1      
 109   1      /* 判断 T0 溢出是否达到 1000 次 */
 110   1      if (cnt >= 1000) {
 111   2      cnt = 0;  // 清零计数值
 112   2      flag = 1; // 定时 1 秒标志置 1
 113   2      }
 114   1      
 115   1      scanDisplayNum();
 116   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              06/27/2021 01:42:17 PAGE 3   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    805    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10      28
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
